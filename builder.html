<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Automated Composite Builder</title>
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
<style>
  :root{ --bg:#0b1020; --panel:#111729; --ink:#e6edf3; --muted:#9aa4b2; --accent:#0ea5e9; --border:#22304a; --radius:14px; --shadow:0 6px 18px rgba(0,0,0,.25); }
  *{box-sizing:border-box}
  body{margin:0; font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial,Helvetica,sans-serif; background:linear-gradient(180deg,#0b1020 0%,#0c172f 100%); color:var(--ink)}
  header{padding:22px 20px 10px; text-align:center}
  header h1{margin:.2rem 0 0; font-size:1.35rem; font-weight:700}
  header p{margin:.3rem 0 0; color:var(--muted); font-size:.95rem}

  .wrap{max-width:1180px; margin:0 auto; padding:8px 18px 70px}
  .card{background:rgba(9,14,28,.6); backdrop-filter:blur(10px); border:1px solid var(--border); border-radius:var(--radius); box-shadow:var(--shadow); margin-top:16px}
  .card h2{font-size:1rem; font-weight:700; margin:0; padding:16px 16px 0}
  .card .body{padding:16px}

  .grid-2{display:grid; grid-template-columns:1.1fr .9fr; gap:16px}
  @media (max-width:980px){ .grid-2{grid-template-columns:1fr}}

  .drop{border:2px dashed #2a3b61; border-radius:12px; padding:18px; text-align:center; color:var(--muted); transition:.2s border-color,.2s background}
  .drop.drag{border-color:var(--accent); background:rgba(14,165,233,.08); color:var(--ink)}
  .drop input{display:none}

  .thumbs{display:grid; grid-template-columns:repeat(auto-fill,minmax(120px,1fr)); gap:12px; margin-top:12px}
  .thumb{border:1px solid var(--border); border-radius:10px; overflow:hidden; background:#0e1425; aspect-ratio:4/5; display:flex; align-items:center; justify-content:center; position:relative}
  .thumb[draggable="true"]{cursor:grab}
  .thumb.dragging{opacity:.5}
  .thumb img{width:100%; height:100%; object-fit:cover}
  .thumb .label{position:absolute; left:0; right:0; bottom:0; background:linear-gradient(180deg,rgba(0,0,0,0) 0,rgba(0,0,0,.55) 85%); color:#fff; font-size:.78rem; padding:6px 8px; text-shadow:0 1px 2px rgba(0,0,0,.5); white-space:nowrap; overflow:hidden; text-overflow:ellipsis}
  .thumb .idx{position:absolute; top:6px; left:6px; font-size:.72rem; background:rgba(0,0,0,.55); color:#fff; padding:2px 6px; border-radius:999px}
  .thumb .remove{position:absolute; right:6px; top:6px; width:24px; height:24px; border-radius:999px; display:flex; align-items:center; justify-content:center; font-weight:700; background:rgba(0,0,0,.55); color:#fff; border:1px solid rgba(255,255,255,.6); opacity:0; transition:.15s; cursor:pointer}
  .thumb:hover .remove{opacity:1}

  .row{display:flex; gap:10px; flex-wrap:wrap}
  .controls{display:grid; grid-template-columns:repeat(2,1fr); gap:12px}
  .controls label{display:block; font-size:.85rem; color:var(--muted); margin-bottom:6px}
  .controls input[type="number"], .controls input[type="text"], .controls select, .controls input[type="color"]{width:100%; padding:10px 12px; border:1px solid var(--border); border-radius:10px; background:#0d1528; color:var(--ink)}
  .subhead{font-weight:700; margin:4px 0 8px; color:var(--ink)}
  .fieldset{border:1px dashed var(--border); border-radius:12px; padding:12px; margin-top:8px}

  .btns{display:flex; flex-wrap:wrap; gap:10px; margin-top:12px}
  button,.btn{appearance:none; border:1px solid #254060; background:#102036; color:#dce7f5; padding:10px 14px; border-radius:10px; cursor:pointer; font-weight:600}
  button.primary{background:var(--accent); border-color:#0ea5e9; color:#00121a}
  button:disabled{opacity:.6; cursor:not-allowed}
  .small{font-size:.85rem; color:var(--muted)}

  .bg-list{display:grid; grid-template-columns:repeat(auto-fill,minmax(140px,1fr)); gap:12px}
  .bg-card{border:1px solid var(--border); border-radius:10px; overflow:hidden; background:#0e1425}
  .bg-card img{display:block; width:100%; height:100px; object-fit:cover}
  .bg-choose{display:flex; align-items:center; gap:8px; padding:8px 10px; border-top:1px solid var(--border)}
  .bg-choose.active{background:#0f1c33}

  #output{padding:16px; display:grid; gap:16px}
  canvas{width:100%; height:auto; image-rendering:crisp-edges; background:#fff; border-radius:8px}

  .hidden-file{display:none}
</style>
</head>
<body>
<header>
  <h1>Automated Composite Builder</h1>
  <p>Tiles forced to <strong>4×5</strong>. Uploads → Settings → Generate. Default 10×8″ @ 300 DPI (3000×2400 px).</p>
</header>

<div class="wrap">

  <!-- 1) Uploads -->
  <section class="card" id="uploads">
    <h2>1) Uploads</h2>
    <div class="body grid-2">
      <div>
        <div id="drop" class="drop" aria-label="Photo dropzone">
          <strong>Drag & drop photos</strong> here or
          <label for="filePick" class="btn" role="button">Browse</label>
          <input id="filePick" type="file" accept="image/*" multiple>
          <div class="small" style="margin-top:8px">Drag thumbnails to set exact order. Click “×” to remove a photo.</div>
        </div>
        <div id="thumbs" class="thumbs" aria-live="polite"></div>
      </div>

      <div>
        <div class="fieldset">
          <div class="subhead">Backgrounds</div>
          <div class="small" style="margin-bottom:10px">Choose one of the 10 built-ins below. (Background&nbsp;1 is selected by default.)</div>
          <div id="bgList" class="bg-list"></div>
          <div class="row" style="justify-content:flex-end; margin-top:10px">
            <label for="bgCustomPick" class="btn" title="Upload a custom background">Upload Custom</label>
            <input id="bgCustomPick" type="file" accept="image/*" class="hidden-file">
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- 2) Settings -->
  <section class="card">
    <h2>2) Settings</h2>
    <div class="body">

      <!-- Title -->
      <div class="fieldset">
        <div class="subhead">Title</div>
        <div class="controls">
          <div><label>School<input id="school" type="text" placeholder="e.g., Lincoln Elementary"></label></div>
          <div><label>Grade<input id="grade" type="text" placeholder="e.g., K–2"></label></div>
          <div><label>Year<input id="year" type="text" placeholder="e.g., 2025–2026"></label></div>
          <div><label>Title font size (px)<input id="titleSize" type="number" value="72" min="20" step="2"></label></div>

          <div><label>Lines
            <select id="titleLines">
              <option value="1" selected>1 line</option>
              <option value="2">2 lines</option>
              <option value="3">3 lines</option>
            </select></label>
          </div>
          <div><label>Placement
            <select id="titlePos">
              <option value="top" selected>Top</option>
              <option value="center">Center Band</option>
            </select></label>
          </div>
          <div><label>Band padding (px)
            <input id="bandPad" type="number" value="36" min="0" step="2">
          </label></div>

          <div style="grid-column:1/-1; border-top:1px dashed var(--border); padding-top:10px; margin-top:4px">
            <div class="subhead" style="margin:0 0 6px">School Logo (optional)</div>
          </div>
          <div><label>Upload Logo
            <label for="logoPick" class="btn" style="display:inline-flex; margin-top:6px">Choose File</label>
            <input id="logoPick" type="file" accept="image/*" class="hidden-file">
            <span id="logoName" class="small" style="margin-left:8px">No file</span>
          </label></div>
          <div><label>Logo height (px)<input id="logoSize" type="number" value="140" min="40"></label></div>
          <div><label>Logo align
            <select id="logoAlign">
              <option value="left" selected>Left</option>
              <option value="center">Center</option>
              <option value="right">Right</option>
            </select></label>
          </div>

          <div style="grid-column:1/-1; margin-top:6px; border-top:1px dashed var(--border); padding-top:10px">
            <div class="subhead" style="margin:0 0 6px">Studio Credit (optional)</div>
            <div class="controls" style="grid-template-columns:repeat(2,1fr); gap:12px">
              <div><label>Studio name<input id="studio" type="text" placeholder="e.g., Example Photography Studio"></label></div>
              <div><label>Credit font size (px)<input id="studioSize" type="number" value="24" min="12" step="1"></label></div>
            </div>
            <div class="small">If provided, the bottom center will show: <em>© Studio Name</em>.</div>
          </div>
        </div>
      </div>

      <!-- Canvas -->
      <div class="fieldset">
        <div class="subhead">Canvas</div>
        <div class="controls">
          <div>
            <label>Preset Size
              <select id="preset">
                <option value="3000x2400">10×8 in @ 300 DPI (3000×2400)</option>
                <option value="2400x3000">8×10 in @ 300 DPI (2400×3000)</option>
                <option value="4500x3600">15×12 in @ 300 DPI (4500×3600)</option>
                <option value="6000x4800">20×16 in @ 300 DPI (6000×4800)</option>
              </select>
            </label>
          </div>
          <div class="row">
            <div style="flex:1"><label>Canvas W (px)<input id="cw" type="number" value="3000" min="800"></label></div>
            <div style="flex:1"><label>Canvas H (px)<input id="ch" type="number" value="2400" min="800"></label></div>
          </div>
          <div class="row">
            <div style="flex:1"><label>Columns (0 = Auto)<input id="cols" type="number" value="0" min="0" step="1"></label></div>
            <div style="flex:1"><label>Rows (0 = Auto)<input id="rows" type="number" value="0" min="0" step="1"></label></div>
          </div>
          <div class="row">
            <div style="flex:1"><label>Gutter (px)<input id="gutter" type="number" value="24" min="0"></label></div>
            <div style="flex:1"><label>Margins (px)<input id="margin" type="number" value="80" min="0"></label></div>
          </div>
          <div class="row">
            <div style="flex:1"><label>Background color (fallback)<input id="bgColor" type="color" value="#ffffff"/></label></div>
            <div style="flex:1; display:flex; align-items:end"><label style="display:flex;align-items:center;gap:8px">
              <input id="fitOne" type="checkbox">
              Fit all on 1 page
            </label></div>
          </div>
        </div>
      </div>

      <!-- Image Names / CSV / Sorting -->
      <div class="fieldset">
        <div class="subhead">Image Names</div>
        <div class="controls">
          <div style="grid-column:1/-1">
            <label>Upload CSV (optional)</label>
            <div class="row" style="align-items:center; margin-top:6px">
              <label for="csvPick" class="btn">Browse CSV</label>
              <input id="csvPick" type="file" accept=".csv,text/csv" class="hidden-file">
              <span class="small" id="csvStatus" style="margin-left:8px">No CSV loaded.</span>
            </div>
            <div class="small" style="margin-top:6px">Headers accepted: <code>first,last</code> (or <code>name</code>), optional <code>filename</code>, <code>grade</code>, <code>teacher</code>.</div>
          </div>

          <div><label>Show names
            <select id="showNames">
              <option value="auto" selected>Auto (on if names exist)</option>
              <option value="on">On</option>
              <option value="off">Off</option>
            </select></label></div>
          <div><label>Name font size (px)<input id="nameSize" type="number" value="36" min="14" step="2"></label></div>
          <div><label>Name color<input id="nameColor" type="color" value="#000000"></label></div>

          <div><label>Sort 1
            <select id="sort1Key">
              <option value="none">(none)</option>
              <option value="grade">Grade</option>
              <option value="teacher">Teacher</option>
              <option value="last">Last name</option>
              <option value="first">First name</option>
            </select></label></div>

          <div><label>Sort 2
            <select id="sort2Key">
              <option value="none">(none)</option>
              <option value="grade">Grade</option>
              <option value="teacher">Teacher</option>
              <option value="last">Last name</option>
              <option value="first">First name</option>
            </select></label></div>

          <div><label>Sort 3
            <select id="sort3Key">
              <option value="none">(none)</option>
              <option value="grade">Grade</option>
              <option value="teacher">Teacher</option>
              <option value="last">Last name</option>
              <option value="first">First name</option>
            </select></label></div>

          <div style="grid-column:1/-1; display:flex; gap:8px; flex-wrap:wrap; margin-top:2px">
            <button id="applySort" class="btn">Apply Sort</button>
            <button id="presetSortCsv" class="btn">Preset: CSV (Grade → Last → First)</button>
            <button id="presetSortCsvOrder" class="btn">Preset: Use CSV Row Order</button>
          </div>
        </div>
      </div>

      <div class="btns">
        <button id="btnGen" class="primary" disabled>Generate Composite</button>
        <button id="btnClear">Clear</button>
        <div class="small" style="align-self:center">Exact pixels → perfect print DPI.</div>
      </div>
    </div>
  </section>

  <!-- 3) Output -->
  <section class="card">
    <h2>3) Output & Export</h2>
    <div class="body">
      <div id="output"></div>
      <div class="btns" id="downloads"></div>
    </div>
  </section>
</div>

<script>
(() => {
  // ----- Elements
  const drop = document.getElementById('drop');
  const filePick = document.getElementById('filePick');
  const thumbs = document.getElementById('thumbs');

  const preset = document.getElementById('preset');
  const cw = document.getElementById('cw');
  const ch = document.getElementById('ch');
  const colsEl = document.getElementById('cols');
  const rowsEl = document.getElementById('rows');
  const marginEl = document.getElementById('margin');
  const gutterEl = document.getElementById('gutter');
  const bgColorEl = document.getElementById('bgColor');
  const fitOneEl = document.getElementById('fitOne');

  const titleLinesEl = document.getElementById('titleLines');
  const titlePosEl   = document.getElementById('titlePos');
  const titleSizeEl  = document.getElementById('titleSize');
  const bandPadEl    = document.getElementById('bandPad');
  const schoolEl = document.getElementById('school');
  const gradeEl  = document.getElementById('grade');
  const yearEl   = document.getElementById('year');
  const logoPick = document.getElementById('logoPick');
  const logoName = document.getElementById('logoName');
  const logoSizeEl = document.getElementById('logoSize');
  const logoAlignEl = document.getElementById('logoAlign');
  const studioEl = document.getElementById('studio');
  const studioSizeEl = document.getElementById('studioSize');

  const showNamesEl = document.getElementById('showNames');
  const nameSizeEl = document.getElementById('nameSize');
  const nameColorEl = document.getElementById('nameColor');

  const csvPick = document.getElementById('csvPick');
  const csvStatus = document.getElementById('csvStatus');
  const sort1Key = document.getElementById('sort1Key');
  const sort2Key = document.getElementById('sort2Key');
  const sort3Key = document.getElementById('sort3Key');
  const applySortBtn = document.getElementById('applySort');
  const presetSortCsvBtn = document.getElementById('presetSortCsv');
  const presetSortCsvOrderBtn = document.getElementById('presetSortCsvOrder');

  const bgList = document.getElementById('bgList');
  const bgCustomPick = document.getElementById('bgCustomPick');

  const btnGen = document.getElementById('btnGen');
  const btnClear = document.getElementById('btnClear');
  const output = document.getElementById('output');
  const downloads = document.getElementById('downloads');

  // ----- State
  let images = [];
  let namesCSV = [];
  let logo = null;
  let backgrounds = [];
  let bgIndex = -1;
  let lastMatchCount = 0;

  function setPreset(){ const [w,h]=preset.value.split('x').map(n=>parseInt(n,10)); cw.value=w; ch.value=h; }
  preset.addEventListener('change', setPreset);

  // Uploads
  ['dragenter','dragover'].forEach(ev=> drop.addEventListener(ev, e=>{ e.preventDefault(); e.stopPropagation(); drop.classList.add('drag'); }));
  ['dragleave','drop'].forEach(ev=> drop.addEventListener(ev, e=>{ e.preventDefault(); e.stopPropagation(); drop.classList.remove('drag'); }));
  drop.addEventListener('drop', e => handlePhotoFiles(e.dataTransfer.files));
  filePick.addEventListener('change', e => { handlePhotoFiles(e.target.files); filePick.value=''; });

  async function handlePhotoFiles(fileList){
    const files = Array.from(fileList).filter(f => f.type.startsWith('image/'));
    if(!files.length) return;
    const loaded = await Promise.all(files.map(loadImageFile));
    images.push(...loaded);
    images.forEach((o,i)=>o._order=i);
    mapNamesToImages();
    refreshThumbs();
    btnGen.disabled = images.length === 0;
    updateCsvStatus();
  }
  function loadImageFile(file){
    return new Promise((resolve,reject)=>{
      const url = URL.createObjectURL(file);
      const img = new Image();
      img.onload = () => resolve({img, url, fileName:(file.name||'').toLowerCase()});
      img.onerror = reject;
      img.src = url;
    });
  }

  function refreshThumbs(){
    thumbs.innerHTML = '';
    images.forEach((o,i)=>{
      const d = document.createElement('div'); d.className='thumb'; d.setAttribute('draggable','true');
      const im = document.createElement('img'); im.src=o.url; d.appendChild(im);
      const idx = document.createElement('div'); idx.className='idx'; idx.textContent = i+1; d.appendChild(idx);
      const label = document.createElement('div'); label.className='label';
      label.textContent = (o.name && o.name.trim()) || o.fileName || `Image ${i+1}`;
      d.appendChild(label);

      const rm = document.createElement('button'); rm.className='remove'; rm.type='button'; rm.textContent='×';
      rm.addEventListener('click', (ev)=>{ ev.stopPropagation(); URL.revokeObjectURL(images[i]?.url); images.splice(i,1); refreshThumbs(); btnGen.disabled = images.length===0; updateCsvStatus(); });
      d.appendChild(rm);

      d.addEventListener('dragstart', ev => { d.classList.add('dragging'); ev.dataTransfer.setData('text/plain', String(i)); });
      d.addEventListener('dragend', ()=> d.classList.remove('dragging'));
      d.addEventListener('dragover', ev => ev.preventDefault());
      d.addEventListener('drop', ev => {
        ev.preventDefault();
        const from = parseInt(ev.dataTransfer.getData('text/plain'),10);
        const to = i;
        if (!Number.isInteger(from) || from===to) return;
        const moved = images.splice(from,1)[0];
        images.splice(to,0,moved);
        images.forEach((o,j)=>o._order=j);
        refreshThumbs();
      });

      thumbs.appendChild(d);
    });
    images.forEach((o,i)=>o._order=i);
  }

  // CSV + sorting (ascending)
  csvPick.addEventListener('change', async (e)=>{
    const file = e.target.files?.[0];
    if(!file){ csvPick.value=''; return; }
    let text = await file.text();
    namesCSV = parseCSV(text);
    mapNamesToImages();
    sortImages();
    refreshThumbs();
    ensureShowNamesAuto();
    updateCsvStatus(true);
    csvPick.value='';
  });

  [sort1Key, sort2Key, sort3Key].forEach(el => el.addEventListener('change', ()=>{ sortImages(); refreshThumbs(); }));
  applySortBtn.addEventListener('click', ()=>{ sortImages(); refreshThumbs(); });

  presetSortCsvBtn.addEventListener('click', ()=>{
    sort1Key.value='grade';
    sort2Key.value='last';
    sort3Key.value='first';
    sortImages(); refreshThumbs();
  });
  presetSortCsvOrderBtn.addEventListener('click', ()=>{
    images.sort((a,b)=>(a._csvIndex ?? Number.POSITIVE_INFINITY) - (b._csvIndex ?? Number.POSITIVE_INFINITY));
    images.forEach((o,i)=>o._order=i);
    refreshThumbs();
  });

  function norm(s){ return (s??'').toString().trim(); }
  function stripBOM(s){ return s.replace(/^\uFEFF/,''); }
  function normKey(s){ return stripBOM(norm(s)).toLowerCase().replace(/\s+/g,' ').replace(/\s/g,'_'); }

  function parseCSV(text){
    text = stripBOM(text);
    const rows=[]; let i=0, cell='', row=[], inQ=false;
    const pushCell=()=>{ row.push(cell); cell=''; };
    const pushRow=()=>{ rows.push(row); row=[]; };
    while(i<text.length){
      const ch=text[i];
      if(inQ){
        if(ch==='"' && text[i+1]==='"'){ cell+='"'; i+=2; continue; }
        if(ch==='"'){ inQ=false; i++; continue; }
        cell+=ch; i++; continue;
      } else {
        if(ch===','){ pushCell(); i++; continue; }
        if(ch==='\n'||ch==='\r'){ if(ch==='\r'&&text[i+1]==='\n') i++; pushCell(); pushRow(); i++; continue; }
        if(ch==='"'){ inQ=true; i++; continue; }
        cell+=ch; i++; continue;
      }
    }
    pushCell(); pushRow();
    if(!rows.length) return [];
    const headers = rows[0].map(normKey);
    const data = rows.slice(1).filter(r=>r.some(c=>norm(c)!==''));

    const idx = (aliases)=>{ for(const a of aliases){ const p=headers.indexOf(normKey(a)); if(p>-1) return p; } return -1; };
    const iFirst = idx(['first','first_name','first name','firstname','given']);
    const iLast  = idx(['last','last_name','last name','lastname','surname','family']);
    const iName  = idx(['name','student','student_name','student name','full_name','full name']);
    const iFile  = idx(['filename','file','photo','image','image_name','image name','imagename']);
    const iGrade = idx(['grade','class','grade_level','grade level']);
    const iTeach = idx(['teacher','homeroom','advisor','instructor']);

    return data.map((r, rowIdx)=>{
      const first = iFirst>-1 ? norm(r[iFirst]) : '';
      const last  = iLast>-1  ? norm(r[iLast])  : '';
      let name    = iName>-1  ? norm(r[iName])  : '';
      if(!name) name = [first,last].filter(Boolean).join(' ');
      return {
        first,last,name,
        filename: iFile>-1 ? norm(r[iFile]).toLowerCase() : '',
        grade:    iGrade>-1? norm(r[iGrade]) : '',
        teacher:  iTeach>-1? norm(r[iTeach]) : '',
        __row: rowIdx
      };
    });
  }

  function nameFromFile(fileName){
    const base = (fileName||'').replace(/\.[^.]+$/,'').replace(/[_\-\.]+/g,' ').replace(/\s+/g,' ').trim();
    return base.replace(/\b\w/g, m=>m.toUpperCase());
  }

  function mapNamesToImages(){
    if(!namesCSV.length){ lastMatchCount=0; return; }
    const byFile=new Map(); namesCSV.forEach(n=>{ if(n.filename) byFile.set(n.filename.toLowerCase(), n); });
    let matched=0;

    images.forEach(img=>{
      const m = byFile.get((img.fileName||'').toLowerCase());
      if(m){
        Object.assign(img, {
          first:m.first,last:m.last,name:m.name||`${m.first} ${m.last}`.trim(),
          grade:m.grade,teacher:m.teacher,
          _csv:m,_csvIndex:m.__row
        });
        matched++;
      }
    });

    const seq = namesCSV.filter(n=>!n.filename);
    let s=0;
    images.forEach(img=>{
      if(!img._csv && s<seq.length){
        const n = seq[s++];
        Object.assign(img, {
          first:n.first,last:n.last,name:n.name||`${n.first} ${n.last}`.trim(),
          grade:n.grade,teacher:n.teacher,
          _csv:n,_csvIndex:n.__row
        });
        matched++;
      }
    });

    images.forEach(img=>{
      if(!img.name || !img.name.trim()) img.name = nameFromFile(img.fileName);
      if(img._csv == null) img._csvIndex = Number.POSITIVE_INFINITY;
    });

    lastMatchCount=matched;
  }

  function updateCsvStatus(){
    if(!namesCSV.length){ csvStatus.textContent='No CSV loaded.'; return; }
    csvStatus.textContent = `CSV loaded: ${namesCSV.length} rows • matched ${lastMatchCount} of ${images.length} photos • Sorting uses CSV fields`;
  }

  function ensureShowNamesAuto(){
    const anyNames = images.some(o => (o.name && o.name.trim()) || o.first || o.last);
    if (showNamesEl.value==='auto' && anyNames) showNamesEl.value='on';
  }

  function gradeRank(raw) {
    if (!raw) return {rank: Number.POSITIVE_INFINITY, norm: ''};
    const s = String(raw).trim().toLowerCase();
    const alias = {
      'pre-school':'ps','preschool':'ps','ps':'ps',
      'pre-k':'pk','prek':'pk','pre k':'pk','prekindergarten':'pk','pk':'pk',
      'tk':'tk','transitional k':'tk','transitional kindergarten':'tk',
      'k':'k','kg':'k','kindergarten':'k'
    };
    const key = alias[s] || s;
    if (key === 'ps') return {rank: -3, norm: 'PS'};
    if (key === 'pk') return {rank: -2, norm: 'PK'};
    if (key === 'tk') return {rank: -1, norm: 'TK'};
    if (key === 'k')  return {rank: 0,  norm: 'K'};
    const range = key.match(/(k|\d+)\s*[-–]\s*(\d+)/i);
    if (range) {
      const a = range[1] === 'k' ? 0 : parseInt(range[1],10);
      return {rank: a, norm: raw};
    }
    const m = key.match(/(\d+)/);
    if (m) return {rank: parseInt(m[1],10), norm: raw};
    return {rank: Number.POSITIVE_INFINITY, norm: raw};
  }
  const coll = new Intl.Collator(undefined, {numeric:true, sensitivity:'base'});
  function cmpText(a, b) {
    if (!a && b) return 1;
    if (!b && a) return -1;
    return coll.compare(a||'', b||'');
  }
  function getSortVal(img, key){
    const src = img._csv || img;
    if (key === 'grade')   return src.grade || img.grade || '';
    if (key === 'teacher') return src.teacher || img.teacher || '';
    if (key === 'last')    return src.last || img.last || '';
    if (key === 'first')   return src.first || img.first || '';
    return '';
  }
  function sortImages(){
    const keys = [sort1Key.value, sort2Key.value, sort3Key.value].filter(k => k && k !== 'none');
    if (!keys.length) return;

    images.forEach((o,i)=>{ o._order = i; if (typeof o._csvIndex !== 'number') o._csvIndex = Number.POSITIVE_INFINITY; });

    images.sort((a, b) => {
      for (const k of keys) {
        let cmp = 0;
        if (k === 'grade') {
          const ga = gradeRank(getSortVal(a,'grade')), gb = gradeRank(getSortVal(b,'grade'));
          cmp = ga.rank === gb.rank ? cmpText(ga.norm, gb.norm) : (ga.rank - gb.rank);
        } else {
          cmp = cmpText(getSortVal(a,k), getSortVal(b,k));
        }
        if (cmp !== 0) return cmp; // ascending only
      }
      if (a._csvIndex !== b._csvIndex) return a._csvIndex - b._csvIndex;
      return a._order - b._order;
    });
  }

  // Logo
  logoPick.addEventListener('change', async (e)=>{
    const file = e.target.files?.[0];
    if(!file){ logoPick.value=''; logoName.textContent='No file'; return; }
    const url = URL.createObjectURL(file);
    const img = new Image();
    img.onload = ()=>{ logo = {img, w:img.naturalWidth, h:img.naturalHeight, url}; logoName.textContent=file.name; };
    img.src = url;
    logoPick.value='';
  });

  // Backgrounds
  async function initBackgrounds(){
    const files = Array.from({length:10}, (_,i)=>`Background${i+1}.jpg`);
    const loaded = await Promise.all(files.map((src, i)=>loadSrcAsImage(src, `Background ${i+1}`)));
    backgrounds = loaded;
    bgIndex = backgrounds.length ? 0 : -1;
    renderBgList();
  }
  function loadSrcAsImage(src,label){
    return new Promise((resolve,reject)=>{
      const img = new Image();
      img.onload = ()=> resolve({img, w:img.naturalWidth, h:img.naturalHeight, label, url:src, isObjectUrl:false});
      img.onerror = ()=> resolve({img:new Image(), w:0, h:0, label, url:src, isObjectUrl:false}); // tolerate missing files
      img.src = src;
    });
  }
  bgCustomPick.addEventListener('change', e => {
    const file = e.target.files?.[0];
    if(!file){ bgCustomPick.value=''; return; }
    const url = URL.createObjectURL(file);
    const img = new Image();
    img.onload = ()=>{
      backgrounds.push({img, w:img.naturalWidth, h:img.naturalHeight, label:'Custom', url, isObjectUrl:true});
      bgIndex = backgrounds.length - 1;
      renderBgList();
    };
    img.src = url;
    bgCustomPick.value='';
  });
  function renderBgList(){
    bgList.innerHTML = '';
    backgrounds.forEach((b, i)=>{
      const card = document.createElement('div'); card.className = 'bg-card';
      const img = document.createElement('img'); img.src=b.img.src; img.alt=b.label; card.appendChild(img);
      const choose = document.createElement('div'); choose.className='bg-choose' + (i===bgIndex?' active':'');
      const radio = document.createElement('input'); radio.type='radio'; radio.name='bgPickRadio';
      radio.checked = i===bgIndex; radio.addEventListener('change', ()=>{ bgIndex = i; renderBgList(); });
      choose.appendChild(radio); choose.appendChild(document.createTextNode(b.label));
      card.appendChild(choose); bgList.appendChild(card);
    });
  }

  // Generate / Clear
  btnGen.addEventListener('click', onGenerate);
  btnClear.addEventListener('click', async ()=>{
    backgrounds.forEach(b=>{ if(b.isObjectUrl && b.url) URL.revokeObjectURL(b.url); });
    images.forEach(o=> o.url && URL.revokeObjectURL(o.url));
    images = []; namesCSV = []; logo = null; output.innerHTML=''; downloads.innerHTML=''; thumbs.innerHTML='';
    btnGen.disabled = true; lastMatchCount = 0; csvStatus.textContent='No CSV loaded.'; logoName.textContent='No file';
    await initBackgrounds();
  });
  document.addEventListener('change', ()=>{ btnGen.disabled = images.length === 0; });

  function onGenerate(){
    output.innerHTML = '';
    downloads.innerHTML = '';

    const W = Math.max(1, parseInt(cw.value,10));
    const H = Math.max(1, parseInt(ch.value,10));
    const M = Math.max(0, parseInt(marginEl.value,10));
    const G = Math.max(0, parseInt(gutterEl.value,10));

    const wantedCols = Math.max(0, parseInt(colsEl.value,10));
    const wantedRows = Math.max(0, parseInt(rowsEl.value,10));

    const bgColor = bgColorEl.value || '#ffffff';

    const namePx = Math.max(12, parseInt(nameSizeEl.value,10) || 36);
    const nameColor = nameColorEl.value || '#000000';
    const logoH = Math.max(20, parseInt(logoSizeEl.value,10));
    const titlePx = Math.max(10, parseInt(titleSizeEl.value,10));
    const titleLines = Math.max(1, Math.min(3, parseInt(titleLinesEl.value,10)));
    const titlePlacement = titlePosEl.value;
    const bandPad = Math.max(0, parseInt(bandPadEl.value,10));
    const lineHeight = Math.ceil(titlePx * 1.12);

    const headerTexts = buildTitleLines(titleLines);

    const studio = (studioEl.value||'').trim();
    const studioPx = Math.max(10, parseInt(studioSizeEl.value,10));

    const anyNames = images.some(o => (o.name && o.name.trim()) || o.first || o.last);
    const showNames = (showNamesEl.value==='on') || (showNamesEl.value==='auto' && anyNames);
    const labelPad = showNames ? Math.ceil(namePx * 1.35) : 0;

    let contentX = M, contentY = M, contentW = W - 2*M, contentH = H - 2*M;

    let topPad = 0;
    if (titlePlacement === 'top' && headerTexts.length){
      const textBlockH = lineHeight * headerTexts.length;
      topPad = textBlockH + 24;
      if (logo) topPad = Math.max(topPad, Math.ceil(logoH + 20));
      contentY += topPad; contentH -= topPad;
    }
    if (contentW<=0 || contentH<=0){ alert('Canvas too small for chosen margins/title.'); return; }

    let bandH = 0;
    if (titlePlacement === 'center' && headerTexts.length){
      const textBlockH = lineHeight * headerTexts.length;
      bandH = textBlockH + 2*bandPad;
    }

    const alignTop = (titlePlacement === 'top');
    const fitAll   = !!fitOneEl.checked;

    const layout = paginateTilesCenterAware(
      images.length, wantedCols, wantedRows,
      contentW, contentH, G, labelPad, bandH,
      alignTop, fitAll
    );
    if (layout.tilesPerPage === 0){ alert('Zero tiles per page with current settings.'); return; }

    const pageCount = layout.pageCount;
    const placements = layout.pagePlacements;
    const baseYOffset = layout.baseYOffset;
    const bandTopWithinContent = layout.bandTopWithin;
    const bandAbsY = contentY + baseYOffset + bandTopWithinContent;

    for(let p=0; p<pageCount; p++){
      const c = document.createElement('canvas');
      c.width = W; c.height = H;
      const ctx = c.getContext('2d');

      // Background
      ctx.fillStyle = bgColor; ctx.fillRect(0,0,W,H);
      if (bgIndex>=0 && backgrounds[bgIndex]) drawCover(ctx, backgrounds[bgIndex].img, 0,0,W,H);

      // Logo
      if (logo){
        const scale = logoH / (logo.h||logo.img.naturalHeight||logo.img.height);
        const w = (logo.w||logo.img.naturalWidth||logo.img.width) * scale;
        let x;
        if (logoAlignEl.value==='left') x = M;
        else if (logoAlignEl.value==='center') x = W/2 - w/2;
        else x = W - M - w; // right
        const yBase = (titlePlacement==='top')
          ? M + Math.max(0,(topPad - logoH)/2)
          : bandAbsY + (Math.max(bandH, logoH) - logoH)/2;
        ctx.drawImage(logo.img, x, yBase, w, logoH);
      }

      // Title text
      if (headerTexts.length){
        ctx.save();
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        ctx.lineWidth = Math.max(2, Math.ceil(titlePx/18));
        ctx.strokeStyle = 'rgba(0,0,0,.6)';
        ctx.fillStyle = '#ffffff';
        ctx.font = `700 ${titlePx}px Inter, Arial, sans-serif`;

        if (titlePlacement === 'top'){
          const textBlockH = Math.ceil(lineHeight * headerTexts.length);
          let y = M + Math.max(0,(topPad - textBlockH)/2);
          headerTexts.forEach(line=>{
            ctx.strokeText(line, W/2, y);
            ctx.fillText(line, W/2, y);
            y += lineHeight;
          });
        } else {
          const textBlockH = Math.ceil(lineHeight * headerTexts.length);
          let y = bandAbsY + bandPad + Math.max(0,(bandH - 2*bandPad - textBlockH)/2);
          headerTexts.forEach(line=>{
            ctx.strokeText(line, W/2, y);
            ctx.fillText(line, W/2, y);
            y += lineHeight;
          });
        }
        ctx.restore();
      }

      // Tiles + names
      const cells = placements[p];
      ctx.font = `600 ${namePx}px Inter, Arial, sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      const stroke = getLuma(nameColor) < 128 ? 'rgba(255,255,255,.85)' : 'rgba(0,0,0,.65)';
      const textStroke = Math.max(2, Math.ceil(namePx/16));

      for (const cell of cells){
        const imgObj = images[cell.index]; if(!imgObj) continue;
        const x = contentX + cell.x;
        const y = contentY + baseYOffset + cell.y;

        drawCropped4x5(ctx, imgObj.img, x, y, cell.tileW, cell.tileH);

        const labelPadDraw = (showNames ? Math.ceil(namePx * 1.35) : 0);
        if (labelPadDraw){
          const name = (imgObj.name || [imgObj.first, imgObj.last].filter(Boolean).join(' ').trim());
          if (name){
            const tx = x + cell.tileW/2;
            const ty = y + cell.tileH + Math.max(4, Math.round(labelPadDraw*0.18));
            ctx.lineWidth = textStroke; ctx.strokeStyle = stroke; ctx.strokeText(name, tx, ty);
            ctx.fillStyle = nameColor; ctx.fillText(name, tx, ty);
          }
        }
      }

      // Studio credit
      const studioNow = (studioEl.value||'').trim();
      if (studioNow){
        ctx.save();
        ctx.textAlign='center'; ctx.textBaseline='alphabetic';
        ctx.font = `600 ${studioPx}px Inter, Arial, sans-serif`;
        ctx.lineWidth = 1.5;
        ctx.strokeStyle = 'rgba(0,0,0,.6)';
        ctx.fillStyle = '#ffffff';
        const text = `© ${studioNow}`;
        const y = H - M - 4;
        ctx.strokeText(text, W/2, y);
        ctx.fillText(text, W/2, y);
        ctx.restore();
      }

      // Output
      output.appendChild(c);
      const a = document.createElement('a');
      a.className='btn';
      a.download = pageCount>1 ? `composite_${p+1}of${pageCount}.png` : 'composite.png';
      a.textContent = `Download ${a.download}`;
      a.href = c.toDataURL('image/png');
      downloads.appendChild(a);
    }
  }

  function getLuma(hex){
    const h = hex.replace('#','');
    const r=parseInt(h.substring(0,2),16), g=parseInt(h.substring(2,4),16), b=parseInt(h.substring(4,6),16);
    return 0.2126*r + 0.7152*g + 0.0722*b;
  }

  function buildTitleLines(nLines){
    const school = (schoolEl.value||'').trim();
    const grade  = (gradeEl.value||'').trim();
    const year   = (yearEl.value||'').trim();

    const lines=[];
    if (nLines===1){
      const a=[]; if(school) a.push(school); if(grade) a.push(`Grade ${grade}`); if(year) a.push(year);
      if (a.length) lines.push(a.join(' • '));
    } else if (nLines===2){
      if (school) lines.push(school);
      const a=[]; if(grade) a.push(`Grade ${grade}`); if(year) a.push(year);
      if (a.length) lines.push(a.join(' • '));
    } else {
      if (school) lines.push(school);
      if (grade)  lines.push(`Grade ${grade}`);
      if (year)   lines.push(year);
    }
    return lines;
  }

  // NEW paginator (rows work, “fit all”, and top-align option)
  function paginateTilesCenterAware(
    count, wantedCols, wantedRows, contentW, contentH, G, labelPad, bandH,
    alignTop = false, fitAll = false
  ){
    const ratio = 4/5;
    const autoC = wantedCols === 0, autoR = wantedRows === 0;

    const effH = contentH - (bandH > 0 ? bandH : 0);
    if (effH <= 0) return {pageCount:0, tilesPerPage:0, pagePlacements:[], baseYOffset:0, bandTopWithin:0};

    function score(c, r){
      let tileW = (contentW - G*(c-1)) / c;
      let tileH = tileW / ratio;
      let cellH = tileH + labelPad;

      const neededH = r*cellH + Math.max(0,(r-1))*G;
      if (neededH > effH){
        const s = effH / neededH;
        tileW *= s; tileH *= s; cellH *= s;
      }
      return {tileW, tileH, cellH, perPage: c*r};
    }

    let best=null, bestC=1, bestR=1;
    const Cmin = autoC ? 1 : wantedCols, Cmax = autoC ? 32 : wantedCols;
    const Rmin = autoR ? 1 : wantedRows, Rmax = autoR ? 32 : wantedRows;

    if (!autoC && !autoR){
      let c = wantedCols, r = wantedRows;
      while (fitAll && (c*r) < count && c < 64) c++;
      bestC=c; bestR=r; best = score(bestC, bestR);
    } else {
      let bestArea=-1;
      for (let C=Cmin; C<=Cmax; C++){
        for (let R=Rmin; R<=Rmax; R++){
          if (fitAll && (C*R) < count) continue;
          const s = score(C,R);
          if (s.perPage < 1) continue;
          const area = s.tileW*s.tileH;
          const better =
            (area > bestArea) ||
            (area === bestArea && s.perPage > (best?.perPage||0)) ||
            (area === bestArea && s.perPage === (best?.perPage||0) && C < (bestC||1));
          if (better){ bestArea = area; best = s; bestC = C; bestR = R; }
        }
      }
      if (!best && fitAll){
        let C = Math.max(1, wantedCols || 1);
        let R = Math.ceil(count / C);
        bestC = C; bestR = R; best = score(C,R);
      }
    }

    if(!best || best.tileW<=0 || best.tileH<=0){
      return {pageCount:0, tilesPerPage:0, pagePlacements:[], baseYOffset:0, bandTopWithin:0};
    }

    const rowsTop    = (bandH > 0) ? Math.floor(bestR/2) : bestR;
    const rowsBottom = (bandH > 0) ? (bestR - rowsTop)    : 0;

    const topH    = rowsTop    * best.cellH + Math.max(0, rowsTop   -1)*G;
    const bottomH = rowsBottom * best.cellH + Math.max(0, rowsBottom-1)*G;

    const usedH = (bandH > 0) ? (topH + bandH + bottomH) : (bestR*best.cellH + Math.max(0,bestR-1)*G);
    const baseYOffset = alignTop ? 0 : Math.max(0, Math.floor((contentH - usedH) / 2));
    const bandTopWithin = (bandH > 0) ? topH : 0;

    const perPage   = Math.max(1, bestC*bestR);
    const pageCount = fitAll ? 1 : Math.ceil(count / perPage);
    const placements = [];

    for (let p=0; p<pageCount; p++){
      const start = p*perPage, end = Math.min(count, start + perPage), cells=[];
      for (let i=start; i<end; i++){
        const k=i-start, r=Math.floor(k/bestC), c=k%bestC;
        const x = c*(best.tileW+G);
        let yRel;

        if (bandH > 0){
          if (r < rowsTop) {
            yRel = r*(best.cellH+G);
          } else {
            yRel = topH + bandH + (r-rowsTop)*(best.cellH+G);
          }
        } else {
          yRel = (alignTop ? 0 : Math.max(0, Math.floor((contentH - usedH)/2))) + r*(best.cellH+G);
        }

        cells.push({x, y: yRel, tileW:best.tileW, tileH:best.tileH, cellH:best.cellH, index:i});
      }
      placements.push(cells);
    }

    return { pageCount, tilesPerPage: perPage, pagePlacements: placements, baseYOffset, bandTopWithin };
  }

  function drawCropped4x5(ctx, img, dx, dy, dw, dh){
    const target=4/5, iw=img.naturalWidth||img.width, ih=img.naturalHeight||img.height, r=iw/ih;
    let sx,sy,sw,sh;
    if(r>target){ sh=ih; sw=ih*target; sx=(iw-sw)/2; sy=0; }
    else{ sw=iw; sh=iw/target; sx=0; sy=(ih-sh)/2; }
    ctx.drawImage(img, sx,sy,sw,sh, dx,dy,dw,dh);
  }
  function drawCover(ctx, img, x,y,w,h){
    const iw=img.naturalWidth||img.width, ih=img.naturalHeight||img.height;
    const s=Math.max(w/iw,h/ih), dw=iw*s, dh=ih*s, dx=x+(w-dw)/2, dy=y+(h-dh)/2;
    ctx.drawImage(img, dx,dy,dw,dh);
  }

  // init
  initBackgrounds();
})();
</script>
</body>
</html>
